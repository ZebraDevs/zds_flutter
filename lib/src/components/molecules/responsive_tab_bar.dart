import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../../../zds_flutter.dart';

/// A TabBar that solves certain issues with Material's TabBar. When using isScrollable is set to true in TabBar, the
/// tabs will not fit the device's width. When isScrollable is set to false, the tabs all have the same size and do not
/// change size to fit their children. This makes it awkward for certain situations where a non-scrollable tab bar is
/// appropriate for certain big devices but not small ones, and where scrollable tab bars do not cover the entire width
/// in big devices.
///
/// This widget solves this issue and makes the tabbar have responsive tab sizes and, if the tabbar does not need to be
/// scrollable, acts as a non-scrollable tab bar fitting exactly the device width. This is done automatically, without
/// needing to specify which tabbar version to use.
///
/// Typically used with a [TabController] and a [TabBarView]
/// ```dart
/// return DefaultTabController(
///   length: 3,
///    child: Column(
///     children: [
///       ZdsResponsiveTabBar(tabs: [ZdsTab(), ZdsTab(),ZdsTab(),],),
///       const Expanded(
///         child: TabBarView(children: [View1(), View2(), View3()],),
///       ),
///     ],
///   ),
/// );
/// ```
///
/// If a [controller] is not provided, then a [DefaultTabController] ancestor must be provided instead. The tab
/// controller's [TabController.length] mustÂ equal the length of the [tabs] list and the length of the
/// [TabBarView.children] list.
///
/// See also:
/// * [ZdsTab], which defines the individual tabs to be used in this tab bar.
class ZdsResponsiveTabBar extends StatelessWidget {
  /// Constructs a [ZdsResponsiveTabBar].
  const ZdsResponsiveTabBar({
    required this.tabs,
    super.key,
    this.controller,
    this.color = ZdsTabBarColor.surface,
    this.selectedLabelFontWeight,
    this.topSafeArea = true,
    this.bottomSafeArea = false,
    this.indicatorColor,
    this.selectedTextColor,
    this.textColor,
  });

  /// The list of tabs that will be displayed in this TabBar. The length of this list must match the [controller]
  /// [TabController.length] and the length of the [TabBarView.children] list.
  final List<ZdsTab> tabs;

  /// An optional controller. If this is not provided, a [DefaultTabController] ancestor must be provided instead.
  final TabController? controller;

  /// The font weight of the label which has a textTheme of [TextTheme.bodyLarge].
  final FontWeight? selectedLabelFontWeight;

  /// Sets the color scheme for each of the tabs and the tab bar itself.
  final ZdsTabBarColor color;

  /// Custom color for selected tab text.
  ///
  /// Overrides [color].
  ///
  /// This will be deprecated in future release, as the value should be autogenerated based on the [color].
  final Color? selectedTextColor;

  /// Custom color for tab text.
  ///
  /// Overrides [color].
  ///
  /// This will be deprecated in future release, as the value should be autogenerated based on the [color].
  final Color? textColor;

  /// Indicator color.
  ///
  /// Overrides [color].
  ///
  /// This will be deprecated in future release, as the value should be autogenerated based on the [color].
  final Color? indicatorColor;

  /// Determine's whether component observes safe area at top of the screen.
  ///
  /// Defaults to true.
  ///
  /// See also:
  /// * [SafeArea].
  final bool topSafeArea;

  /// Determine's whether component observes safe area at bottom of the screen.
  ///
  /// Defaults to false.
  ///
  /// See also:
  /// * [SafeArea].
  final bool bottomSafeArea;

  @override
  Widget build(BuildContext context) {
    final int numberOfTabs = tabs.length;
    final ZdsAppBar? appBar = context.findAncestorWidgetOfExactType<ZdsAppBar>();

    final customThemeContainer = ZdsTabBar.buildTheme(
      context,
      color: appBar != null ? appBar.color : color,
      hasIcons: hasIcons(tabs),
    );

    final ZdsTabBarThemeData customTheme = customThemeContainer.customTheme;

    return DecoratedBox(
      decoration: customTheme.decoration,
      child: SafeArea(
        top: topSafeArea,
        bottom: bottomSafeArea,
        child: LayoutBuilder(
          builder: (context, constraints) {
            // 16*2 refers to kTabLabelPadding (on both sides of the label)
            double minWidth = constraints.maxWidth / numberOfTabs - (16 * 2);
            minWidth = minWidth > 0 ? minWidth : 12;
            return Theme(
              data: customThemeContainer.theme,
              child: SizedBox(
                height: customTheme.height + 1,
                child: TabBar(
                  controller: controller,
                  indicatorWeight: 1,
                  isScrollable: true,
                  labelStyle:
                      (hasIcons(tabs) ? Theme.of(context).textTheme.bodySmall : Theme.of(context).textTheme.bodyLarge)
                          ?.copyWith(
                    fontWeight: selectedLabelFontWeight,
                  ),
                  labelColor: selectedTextColor,
                  unselectedLabelColor: textColor,
                  indicatorColor: indicatorColor,
                  tabs: <Widget>[
                    for (final ZdsTab tab in tabs)
                      ConstrainedBox(
                        constraints: BoxConstraints(minWidth: minWidth),
                        child: tab,
                      ),
                  ],
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty<TabController?>('controller', controller))
      ..add(DiagnosticsProperty<FontWeight?>('selectedLabelFontWeight', selectedLabelFontWeight))
      ..add(EnumProperty<ZdsTabBarColor>('color', color))
      ..add(DiagnosticsProperty<bool>('topSafeArea', topSafeArea))
      ..add(ColorProperty('selectedTextColor', selectedTextColor))
      ..add(ColorProperty('textColor', textColor))
      ..add(ColorProperty('indicatorColor', indicatorColor))
      ..add(DiagnosticsProperty<bool>('bottomSafeArea', bottomSafeArea));
  }
}
